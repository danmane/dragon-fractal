<head>
  <meta charset="UTF-8">
  <script src="bower_components/d3/d3.js"></script>
  <script>!function(){function t(t){return function(e,i){e=d3.hsl(e),i=d3.hsl(i);var r=(e.h+120)*a,h=(i.h+120)*a-r,s=e.s,l=i.s-s,o=e.l,u=i.l-o;return isNaN(l)&&(l=0,s=isNaN(s)?i.s:s),isNaN(h)&&(h=0,r=isNaN(r)?i.h:r),function(a){var e=r+h*a,i=Math.pow(o+u*a,t),c=(s+l*a)*i*(1-i);return"#"+n(i+c*(-.14861*Math.cos(e)+1.78277*Math.sin(e)))+n(i+c*(-.29227*Math.cos(e)-.90649*Math.sin(e)))+n(i+c*1.97294*Math.cos(e))}}}function n(t){var n=(t=0>=t?0:t>=1?255:0|255*t).toString(16);return 16>t?"0"+n:n}var a=Math.PI/180;d3.scale.cubehelix=function(){return d3.scale.linear().range([d3.hsl(300,.5,0),d3.hsl(-240,.5,1)]).interpolate(d3.interpolateCubehelix)},d3.interpolateCubehelix=t(1),d3.interpolateCubehelix.gamma=t}();</script>
</head>
<body>
  <style>
    #main {width: 100%; height: 100% ; background-color: black;}
    path {stroke-width: 2px; stroke-linecap: round; fill: none;}
    body {margin: 0px;}
  </style>
  <svg id="main">
    <g id="rescale" transform="scale(0,0) translate(0,0)">
      <circle id="rotator" r="3" fill="white" style="display:none;"/>
      <rect id="box" x="0" y="0" width="10" height="0" fill="grey" />
      <rect id="margin" x="0" y="0" width="10" height="0" fill="aliceblue" />
      <g id="origin">
        <g id="start"><path d="M 0 0 L 0 0"/></g>
      </g>
    </g>
  </svg>
  <script>
  rotator = d3.select("#rotator")
  r =d3.select("svg").node().getBoundingClientRect();
  outerWidth= r.width
  outerHeight = r.height;
  id=0, TRANSITION_DURATION=1000, ds=1.1, o=d3.select("#start"), NUM_STEPS=15;
  STARTING_RATIO = 4;
  next = false
  len = 10
  x=10, y=10
  var box = {
    minx: 0,
    maxx: x,
    miny: 0,
    maxy: y,
  }
  function futureBox(iters) {
    b = {
      minx: 0,
      maxx: x,
      miny: 0,
      maxy: y,
    }
    _about = [x,y]
    for (var i=0; i<iters; i++) {
      b = rotateBox(b, _about)
      _about = rotate([0,0], _about)
    }
    return b;
  }

  function drawBox(seq) {
    var xs=seq.map(function(x){return x[0]}),ys=seq.map(function(x){return x[1]})
    var minx = d3.min(xs), maxx = d3.max(xs), miny = d3.min(ys), maxy = d3.max(ys)
    var innerWidth = (maxx - minx)
    var innerHeight = (maxy - miny)
    var margin_realpix = 50
    var ratio = Math.min(outerWidth/(innerWidth+2*margin_realpix), outerHeight/(innerHeight+2*margin_realpix), STARTING_RATIO);
    var margin_fakepix = margin_realpix / ratio
    var xt = (outerWidth - innerWidth * ratio)/(2*ratio)
    var yt = (outerHeight - innerHeight * ratio)/(2*ratio)
    s = d3.select("#rescale")
    // if (ratio === STARTING_RATIO) return
    xform = "scale("+[ratio,ratio]+") translate(" + [-minx+xt,-miny+yt] + ")"
    s = s.transition().ease(d3.ease("cubic-in-out", 3)).duration(TRANSITION_DURATION)
    s.attr("transform", xform)
    // d3.select("#box").attr({
    //   width: b.maxx-b.minx,
    //   height: b.maxy-b.miny,
    //   x: b.minx,
    //   y: b.miny
    // })
    // debugger;
    // d3.select("#box").attr({x: b.minx, y: b.miny, height: b.maxy-b.miny, width: b.maxx-b.minx})
  }

  function rotate(vec, about){
    var x = vec[0]-about[0]
    var y = vec[1]-about[1]
    return [about[0] - y, about[1] + x]
  }

  function rotateBox(box, about) {
    var c1 = rotate([box.minx, box.miny], about)
    var c2 = rotate([box.maxx, box.maxy], about)
    var b = {
      minx: Math.min(c1[0], c2[0], box.minx),
      maxx: Math.max(c1[0], c2[0], box.maxx),
      miny: Math.min(c1[1], c2[1], box.miny),
      maxy: Math.max(c1[1], c2[1], box.maxy)
    }
    return b
  }


  var segments = [[[0,0], [x,y]]]
  var total = segments[0]

  function extend() {
    function r(x) {
      return rotate(x, total[total.length-1])
    }
    newS = total.map(r).reverse()
    segments.push(newS)
    total = total.concat(newS.slice(1))
  }



  rotatePt = [x,y]
  // box = rotateBox(box, rotatePt)
  // drawBox(box)
  h=d3.hsl,cs_ = d3.scale.cubehelix().domain([-0.2, 0.5, 1])
    .range([h(-100, 0.75, 0.35),h(80,1.50,0.80),h(260, 0.75, 0.35)])
  d = ["M 0 0 L",x,y].join(" ")
  function cs(x) {return cs_(x/NUM_STEPS)}
  // p=d3.select("path").attr("d",d),

  d3.select("path").style("stroke", cs(0)).transition().duration(TRANSITION_DURATION).attr("d", d);
  setTimeout(update, TRANSITION_DURATION);
  clone = null;
  function update() {
    id++// = (id + 1) % (NUM_STEPS * 2);
    if (id < NUM_STEPS) {
      if (clone) {
        extend();
        pathd = d3.svg.line()(segments[segments.length-1])
        clone.remove()
        o.append("path").attr("d", pathd).style("stroke", cs(id-1))
        debugger;

      }
      drawBox(total)
      a = "rotate(0 " + rotatePt + ")", b = "rotate(90 " + rotatePt + ")"
      rotator.attr("cx", rotatePt[0]).attr("cy", rotatePt[1])
      w = function() {return d3.interpolateString(a,b)}
      last = o.node().children[o.node().children.length-1]
      box=rotateBox(box, rotatePt)
      // drawBox(box)
      rotatePt = rotate([0,0], rotatePt)
      last.style = "stroke: " + cs((id-1))
      Array.prototype.forEach.call(last.children, function(x) {x.style=""})
      clone = o.node().cloneNode(true)
      g=d3.select(o.node().appendChild(clone))
      allChildren = g.selectAll("path");//d3.selectAll(g.node().children)
      allChildren.transition().duration(TRANSITION_DURATION).style("stroke", cs(id))
      g.transition().duration(TRANSITION_DURATION).attrTween("transform", w)
      setTimeout(update, TRANSITION_DURATION);
    } else {
      // if (next) {next.remove()} else {d*=15}
      // children = o.node().children, next = children[children.length-1]
      // reattach = o.node()
      // o = o.append("g")
      // while (children.length > 2) {
      //   o.node().appendChild(children[0])
      // }
      // reattach.appendChild(rotator.node())
      // o.transition().duration(d).attrTween("transform", w)
      // setTimeout(update, d);
    }
  }
  </script>
</body>
