<head>
  <script src="bower_components/d3/d3.min.js"></script>
  <script>!function(){function t(t){return function(e,i){e=d3.hsl(e),i=d3.hsl(i);var r=(e.h+120)*a,h=(i.h+120)*a-r,s=e.s,l=i.s-s,o=e.l,u=i.l-o;return isNaN(l)&&(l=0,s=isNaN(s)?i.s:s),isNaN(h)&&(h=0,r=isNaN(r)?i.h:r),function(a){var e=r+h*a,i=Math.pow(o+u*a,t),c=(s+l*a)*i*(1-i);return"#"+n(i+c*(-.14861*Math.cos(e)+1.78277*Math.sin(e)))+n(i+c*(-.29227*Math.cos(e)-.90649*Math.sin(e)))+n(i+c*1.97294*Math.cos(e))}}}function n(t){var n=(t=0>=t?0:t>=1?255:0|255*t).toString(16);return 16>t?"0"+n:n}var a=Math.PI/180;d3.scale.cubehelix=function(){return d3.scale.linear().range([d3.hsl(300,.5,0),d3.hsl(-240,.5,1)]).interpolate(d3.interpolateCubehelix)},d3.interpolateCubehelix=t(1),d3.interpolateCubehelix.gamma=t}();</script>
</head>
<body>
  <style>
    svg {width: 100%; height: 100% ; background-color: black;}
    path {stroke-width: 1.5px; stroke-linecap: round; fill: none;}
    body {margin: 0px;}
  </style>
  <svg></svg>
  <script>
  r=d3.select("svg").node().getBoundingClientRect()
  outerWidth=r.width, outerHeight = r.height;
  step=0, TRANSITION_DURATION=100, ds=1.1, NUM_STEPS=14;
  STARTING_RATIO = 4;
  x=0, y=10
  s = d3.select("svg").append("g")

  function computeTransform(seq) {
    var xs=seq.map(function(x){return x[0]}),ys=seq.map(function(x){return x[1]})
    var minx = d3.min(xs), maxx = d3.max(xs), miny = d3.min(ys), maxy = d3.max(ys)
    var innerWidth = (maxx - minx)
    var innerHeight = (maxy - miny)
    var margin_realpix = 50
    var ratio = Math.min(outerWidth/(innerWidth+2*margin_realpix), outerHeight/(innerHeight+2*margin_realpix), STARTING_RATIO);
    var margin_fakepix = margin_realpix / ratio
    var xt = (outerWidth - innerWidth * ratio)/(2*ratio)
    var yt = (outerHeight - innerHeight * ratio)/(2*ratio)
    xform = "scale("+[ratio,ratio]+") translate(" + [-minx+xt,-miny+yt] + ")"
    return xform
  }

  function rotate(vec, about){
    var x = vec[0]-about[0]
    var y = vec[1]-about[1]
    return [about[0] - y, about[1] + x]
  }
  function last(x) {return x[x.length-1]}

  var segments = [[[0,0], [x,y]]]
  var totals = segments.slice()

  function extend() {
    function r(x) { return rotate(x, last(last(totals))) }
    var newS = last(totals).map(r).reverse()
    segments.push(newS)
    var newT = last(totals).concat(newS.slice(1))
    totals.push(newT)
  }
  for (var i=0; i<NUM_STEPS; i++) {extend()}

  h=d3.hsl,cs_ = d3.scale.cubehelix().domain([-0.2, 0.5, 1]).range([h(-100, 0.75, 0.35),h(80,1.50,0.80),h(260, 0.75, 0.35)])
  function cs(x) {return cs_(x/NUM_STEPS)}

  s.attr("transform", computeTransform(totals[0]))
  s.append("path").attr("d", "M0,0 L0,0").style("stroke", cs(0)).transition().duration(TRANSITION_DURATION).attr("d", d3.svg.line()(totals[0]));
  setTimeout(unfold1, TRANSITION_DURATION);

  function unfold1() {
    step++
    rotatePt = last(totals[step-1])
    a = "rotate(0 " + rotatePt + ")", b = "rotate(90 " + rotatePt + ")"
    w = function() {return d3.interpolateString(a,b)}
    clone = s.node().cloneNode(true)
    g=d3.select(s.node().appendChild(clone))
    g.selectAll("path").transition().duration(TRANSITION_DURATION).style("stroke", cs(step))
    g.transition().duration(TRANSITION_DURATION).attrTween("transform", w)
    s.transition().duration(TRANSITION_DURATION).attr("transform", computeTransform(totals[step]))
    setTimeout(unfold2, TRANSITION_DURATION);
      // if (next) {next.remove()} else {d*=15}
      // children = o.node().children, next = children[children.length-1]
      // reattach = o.node()
      // o = o.append("g")
      // while (children.length > 2) {
      //   o.node().appendChild(children[0])
      // }
      // reattach.appendChild(rotator.node())
      // o.transition().duration(d).attrTween("transform", w)
      // setTimeout(update, d);
  }

  function unfold2() {
    pathd = d3.svg.line()(segments[step])
    clone.remove()
    s.append("path").attr("d", pathd).style("stroke", cs(step))
    if (step < NUM_STEPS) {
      unfold1()
    }
  }
  </script>
</body>
