<head>
  <script src="bower_components/d3/d3.min.js"></script>
  <script>!function(){function t(t){return function(e,i){e=d3.hsl(e),i=d3.hsl(i);var r=(e.h+120)*a,h=(i.h+120)*a-r,s=e.s,l=i.s-s,o=e.l,u=i.l-o;return isNaN(l)&&(l=0,s=isNaN(s)?i.s:s),isNaN(h)&&(h=0,r=isNaN(r)?i.h:r),function(a){var e=r+h*a,i=Math.pow(o+u*a,t),c=(s+l*a)*i*(1-i);return"#"+n(i+c*(-.14861*Math.cos(e)+1.78277*Math.sin(e)))+n(i+c*(-.29227*Math.cos(e)-.90649*Math.sin(e)))+n(i+c*1.97294*Math.cos(e))}}}function n(t){var n=(t=0>=t?0:t>=1?255:0|255*t).toString(16);return 16>t?"0"+n:n}var a=Math.PI/180;d3.scale.cubehelix=function(){return d3.scale.linear().range([d3.hsl(300,.5,0),d3.hsl(-240,.5,1)]).interpolate(d3.interpolateCubehelix)},d3.interpolateCubehelix=t(1),d3.interpolateCubehelix.gamma=t}();</script>
</head>
<body>
  <style>
    svg {width: 100%; height: 100% ; background-color: black;}
    path {stroke-width: 1.5px; stroke-linecap: round; fill: none;}
    body {margin: 0px;}
  </style>

  <svg></svg>
  <script>
  TD=500, TS=1.15, NUM_STEPS=2;
  STARTING_RATIO = 4;
  s=null

  function computeTransform(seq) {
    r=d3.select("svg").node().getBoundingClientRect()
    outerWidth=r.width, outerHeight = r.height;
    var xs=seq.map(function(x){return x[0]}),ys=seq.map(function(x){return x[1]})
    var minx = d3.min(xs), maxx = d3.max(xs), miny = d3.min(ys), maxy = d3.max(ys)
    var innerWidth = (maxx - minx)
    var innerHeight = (maxy - miny)
    var margin_realpix = 50
    var ratio = Math.min(outerWidth/(innerWidth+2*margin_realpix), outerHeight/(innerHeight+2*margin_realpix), STARTING_RATIO);
    var margin_fakepix = margin_realpix / ratio
    var xt = (outerWidth - innerWidth * ratio)/(2*ratio)
    var yt = (outerHeight - innerHeight * ratio)/(2*ratio)
    xform = "scale("+[ratio,ratio]+") translate(" + [-minx+xt,-miny+yt] + ")"
    return xform
  }

  function effectZoom(seq) {
    var xform = computeTransform(seq)
    s.transition().duration(TD).attr("transform", xform)
  }

  function rotate(vec, about){
    var x = vec[0]-about[0]
    var y = vec[1]-about[1]
    return [about[0] - y, about[1] + x]
  }
  function last(x) {return x[x.length-1]}



  function setup(xy) {
    step = 0
    if (s) s.remove()
    s = d3.select("svg").append("g")
    segments = [[[0,0], xy]]
    totals = segments.slice()
    s.attr("transform", computeTransform([[0,0]]))
    p = s.append("path").style("stroke", cs(0)).attr("d", "M0,0 L0,0")
    p.transition().duration(TD).attr("d", d3.svg.line()(totals[0]))
    setTimeout(unfold1, TD);
  }


  function extend() {
    function r(x) { return rotate(x, last(last(totals))) }
    var newS = last(totals).map(r).reverse()
    segments.push(newS)
    var newT = last(totals).concat(newS.slice(1))
    totals.push(newT)
  }

  h=d3.hsl,cs_ = d3.scale.cubehelix().domain([-0.2, 0.5, 1]).range([h(-100, 0.75, 0.35),h(80,1.50,0.80),h(260, 0.75, 0.35)])
  function cs(x) {return cs_(x/NUM_STEPS)}


  function unfold1() {
    step++
    extend()
    TD *= TS
    rotatePt = last(totals[step-1])
    a = "rotate(0 " + rotatePt + ")", b = "rotate(90 " + rotatePt + ")"
    w = function() {return d3.interpolateString(a,b)}
    clone = s.node().cloneNode(true)
    g=d3.select(s.node().appendChild(clone))
    g.selectAll("path").transition().duration(TD).style("stroke", cs(step))
    g.transition().duration(TD).attrTween("transform", w)
    effectZoom(totals[step])
    setTimeout(unfold2, TD);
  }

  function unfold2() {
    pathd = d3.svg.line()(segments[step])
    clone.remove()
    s.append("path").attr("d", pathd).style("stroke", cs(step)).classed(step, true)
    if (step < NUM_STEPS) {
      unfold1()
    } else {
      c=s
      setTimeout(refold1, TD/2)
    }
  }

  function refold1() {
    step--
    TD /= TS
    children = c.node().children
    c = c.append("g")
    rotatePt = last(segments[step])
    a = "rotate(0 " + rotatePt + ")", b = "rotate(90 " + rotatePt + ")"
    w = function() {return d3.interpolateString(a,b)}
    while (children.length > 2) {c.node().appendChild(children[0])}
    c.transition().duration(TD).attrTween("transform", w)
    effectZoom(unextend())
    setTimeout(refold2, TD)
  }

  function unextend() {
    var rp = last(totals[step])
    function r(x) {return rotate(x, (rp))}
    totals = totals.map(function(s) {
      return s.map(r)
    })
    return totals[step]
  }

  function refold2() {
    children[0].remove()
    if (step > 0) {
      refold1();
    } else {
      newxy = rotate(segments[0][1], [0,0])
      function f() {setup(newxy)}
      d = d3.svg.line()([totals[0][0], totals[0][0]])
      d3.select("path").transition().duration(TD).attr("d", d)
      effectZoom([[0,0]])
      debugger;
      setTimeout(f, TD)
    }
  }
  setup([0,10])
  </script>
</body>
